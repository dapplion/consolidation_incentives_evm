# Implementation Plan: Consolidation Incentives EVM (Gnosis Chain)

A three-component system: **Solidity smart contract**, **Rust proof service**, and **monitoring/visualization**, with shared test vectors ensuring cross-component compatibility.

---

## Repository Structure

```
consolidation_incentives_evm/
├── contracts/                          # Foundry project
│   ├── foundry.toml
│   ├── src/
│   │   ├── ConsolidationIncentives.sol       # Main contract (UUPSUpgradeable)
│   │   └── lib/
│   │       └── SSZMerkleVerifier.sol          # SSZ proof verification library
│   ├── test/
│   │   ├── ConsolidationIncentives.t.sol      # Full integration tests
│   │   ├── SSZMerkleVerifier.t.sol            # Proof library unit tests
│   │   └── mocks/
│   │       └── MockBeaconRootsOracle.sol      # Mock EIP-4788 for tests
│   ├── script/
│   │   └── Deploy.s.sol
│   └── test-vectors/                          # JSON test vectors (generated by Rust)
│       └── *.json
│
├── prover/                             # Rust proof service (Cargo workspace)
│   ├── Cargo.toml
│   ├── crates/
│   │   ├── proof-gen/                         # Core proof generation logic
│   │   │   ├── Cargo.toml
│   │   │   └── src/
│   │   │       ├── lib.rs
│   │   │       ├── beacon_client.rs           # Beacon API HTTP client
│   │   │       ├── proof.rs                   # SSZ proof computation
│   │   │       ├── gindex.rs                  # Generalized index math
│   │   │       └── types.rs                   # Beacon state types
│   │   ├── service/                           # REST API + auto-submitter
│   │   │   ├── Cargo.toml
│   │   │   └── src/
│   │   │       ├── main.rs
│   │   │       ├── api.rs                     # Axum REST endpoints
│   │   │       ├── submitter.rs               # On-chain tx submission via alloy
│   │   │       ├── scanner.rs                 # Beacon chain consolidation scanner
│   │   │       └── state.rs                   # Shared AppState
│   │   └── test-vectors/                      # Test vector generator binary
│   │       ├── Cargo.toml
│   │       └── src/
│   │           └── main.rs                    # Generates JSON test vectors
│   └── tests/
│       └── integration.rs
│
└── dune/                               # Dune SQL queries for dashboard
    └── queries/
        ├── total_rewards.sql
        ├── consolidations_over_time.sql
        └── top_validators.sql
```

---

## Part 1: Smart Contract (Foundry/Solidity)

### Step 1.1: Project Scaffolding

- `forge init contracts --no-commit`
- Install: `openzeppelin-contracts-upgradeable`, `openzeppelin-contracts`, `forge-std`
- Configure `foundry.toml`: solc 0.8.28, optimizer 200 runs, remappings

### Step 1.2: `SSZMerkleVerifier.sol` Library

A pure library for SSZ Merkle proof verification.

**Core function:**
```solidity
function verifyProof(
    bytes32 root,
    bytes32 leaf,
    bytes32[] calldata proof,
    uint256 gindex
) internal view returns (bool)
```

- Walks leaf→root using `gindex` bits: even = left child, odd = right child
- Uses SHA256 precompile at `address(0x02)` via `staticcall` (64-byte input → 32-byte hash)
- Proof length must equal `floor(log2(gindex))`

**Gindex helpers** (all `pure`, constants computed at compile time):

```solidity
// Full gindex from block_root to each leaf:

// pending_consolidations[i].source_index
// Path: header(3) → state(6) → list_data(1) → element[i](18) → field_0(1) = 29 depth
function consolidationSourceGindex(uint64 consolidationIndex) → uint256

// validators[i].withdrawal_credentials
// Path: header(3) → state(6) → list_data(1) → element[i](40) → field_1(3) = 53 depth
function validatorCredentialsGindex(uint64 validatorIndex) → uint256

// validators[i].activation_epoch
// Path: header(3) → state(6) → list_data(1) → element[i](40) → field_5(3) = 53 depth
function validatorActivationEpochGindex(uint64 validatorIndex) → uint256
```

**SSZ little-endian encoding:**
```solidity
function toLittleEndian64(uint64 value) → bytes32
// Reverses 8 bytes of uint64, places in first 8 bytes of bytes32
```

### Step 1.3: `ConsolidationIncentives.sol`

**Inheritance:** `UUPSUpgradeable`, `OwnableUpgradeable`

**Constants:**
| Name | Value | Description |
|---|---|---|
| `EIP4788_ORACLE` | `0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02` | Beacon root oracle |
| `CONSOLIDATION_PROOF_LENGTH` | 29 | Siblings for consolidation proof |
| `VALIDATOR_PROOF_LENGTH` | 53 | Siblings for validator field proofs |

**Storage (set in `initialize()`):**
| Name | Type | Description |
|---|---|---|
| `maxEpoch` | `uint64` | Eligibility cutoff epoch |
| `rewardAmount` | `uint256` | Fixed xDAI per claim |
| `minClaimDelay` | `uint256` | Seconds before referenced beacon timestamp is usable |
| `rewarded` | `mapping(uint64 => bool)` | Tracks claimed validator indices |

**Main function: `claimReward()`**

```solidity
function claimReward(
    uint64  beaconTimestamp,         // EIP-4788 lookup key
    uint64  consolidationIndex,      // Index in pending_consolidations
    uint64  sourceIndex,             // Validator index
    uint64  activationEpoch,         // Source validator's activation epoch
    bytes32 sourceCredentials,       // Withdrawal credentials
    bytes32[] calldata proofConsolidation,   // 29 elements
    bytes32[] calldata proofCredentials,     // 53 elements
    bytes32[] calldata proofActivationEpoch  // 53 elements
) external
```

**Logic sequence:**
1. `require(!rewarded[sourceIndex])` — double-claim guard
2. `require(block.timestamp - beaconTimestamp >= minClaimDelay)` — finality safety
3. Call EIP-4788 at `beaconTimestamp` → `blockRoot` (revert if not found / zero)
4. Verify `proofConsolidation`: leaf = `toLittleEndian64(sourceIndex)`, gindex = `consolidationSourceGindex(consolidationIndex)`
5. Verify `proofCredentials`: leaf = `sourceCredentials`, gindex = `validatorCredentialsGindex(sourceIndex)`
6. Verify `proofActivationEpoch`: leaf = `toLittleEndian64(activationEpoch)`, gindex = `validatorActivationEpochGindex(sourceIndex)`
7. `require(activationEpoch < maxEpoch)` — eligibility
8. Validate credential prefix: `sourceCredentials[0] == 0x01 || sourceCredentials[0] == 0x02`
9. Extract address: `address(uint160(uint256(sourceCredentials)))` (last 20 bytes)
10. `rewarded[sourceIndex] = true`
11. Transfer `rewardAmount` native token to extracted address
12. Emit `RewardClaimed(sourceIndex, recipient, rewardAmount)`

**Additional functions:**
- `receive() external payable` — accept funding
- `withdraw(address to, uint256 amount) onlyOwner` — withdraw excess
- `_authorizeUpgrade(address) onlyOwner` — UUPS guard

### Step 1.4: Tests — 100% Coverage

#### `test/mocks/MockBeaconRootsOracle.sol`
- Stores `mapping(uint256 => bytes32)` of timestamp → root
- Deployed at EIP-4788 address via `vm.etch` in tests

#### `test/SSZMerkleVerifier.t.sol` — Proof library unit tests
| Test | Description |
|---|---|
| `test_validProof_depth1` | Minimal tree (2 leaves), correct proof passes |
| `test_validProof_depth3` | 8-leaf tree, verify leaf at various positions |
| `test_validProof_depth29` | Consolidation-depth proof |
| `test_validProof_depth53` | Validator-depth proof |
| `test_wrongLeaf_reverts` | Correct proof + wrong leaf → fails |
| `test_wrongRoot_reverts` | Correct proof + wrong root → fails |
| `test_wrongProof_singleBitFlip` | One sibling hash modified → fails |
| `test_wrongGindex_reverts` | Wrong gindex (wrong position) → fails |
| `test_wrongProofLength_reverts` | Proof length != log2(gindex) → fails |
| `test_emptyProof_reverts` | Zero-length proof → fails |
| `test_gindexOne_noProof` | Gindex 1 (root) — leaf must equal root |
| `test_toLittleEndian64` | Encode various uint64 values |
| `test_gindexComputation_consolidation` | Verify gindex math for known indices |
| `test_gindexComputation_validator` | Verify gindex math for known indices |

#### `test/ConsolidationIncentives.t.sol` — Integration tests

**Uses JSON test vectors** generated by Rust (loaded via `vm.parseJson`).

| Test | Description |
|---|---|
| **Happy path** | |
| `test_claimReward_success` | Valid claim → transfers reward to correct address |
| `test_claimReward_0x02credentials` | Compounding credentials (0x02) accepted |
| `test_claimReward_multipleValidators` | Multiple different validators claim successfully |
| `test_claimReward_emitsEvent` | Check `RewardClaimed` event fields |
| **Double-claim** | |
| `test_claimReward_doubleClaim_reverts` | Same sourceIndex twice → reverts |
| `test_claimReward_differentConsolidationIndex_sameSource_reverts` | Same source, different consolidation entry → reverts |
| **Eligibility** | |
| `test_claimReward_activationEpochTooHigh_reverts` | `activationEpoch >= maxEpoch` → reverts |
| `test_claimReward_activationEpochExactlyMaxEpoch_reverts` | `activationEpoch == maxEpoch` → reverts |
| `test_claimReward_activationEpochMaxEpochMinusOne_succeeds` | `activationEpoch == maxEpoch - 1` → succeeds |
| **Finality** | |
| `test_claimReward_timestampTooRecent_reverts` | `block.timestamp - beaconTimestamp < minClaimDelay` → reverts |
| `test_claimReward_timestampExactDelay_succeeds` | Exactly at delay boundary → succeeds |
| `test_claimReward_timestampNotInOracle_reverts` | EIP-4788 returns zero → reverts |
| **Invalid proofs** | |
| `test_claimReward_wrongConsolidationProof_reverts` | Tampered consolidation proof |
| `test_claimReward_wrongCredentialsProof_reverts` | Tampered credentials proof |
| `test_claimReward_wrongActivationEpochProof_reverts` | Tampered activation proof |
| `test_claimReward_wrongSourceIndex_reverts` | Proof valid but sourceIndex doesn't match |
| `test_claimReward_wrongCredentials_reverts` | Proof valid but credentials don't match |
| `test_claimReward_wrongActivationEpoch_reverts` | Proof valid but epoch doesn't match |
| `test_claimReward_swappedProofs_reverts` | Proofs in wrong parameter positions |
| `test_claimReward_truncatedProof_reverts` | Proof missing elements |
| `test_claimReward_extendedProof_reverts` | Proof with extra elements |
| **Credential edge cases** | |
| `test_claimReward_0x00credentials_reverts` | BLS credentials (0x00) rejected |
| `test_claimReward_0xFFcredentials_reverts` | Unknown prefix rejected |
| **Funding** | |
| `test_claimReward_insufficientBalance_reverts` | Contract can't pay → reverts |
| `test_receive_acceptsFunding` | Contract accepts xDAI |
| **Admin** | |
| `test_withdraw_onlyOwner` | Non-owner withdraw → reverts |
| `test_withdraw_success` | Owner withdraws funds |
| `test_upgrade_onlyOwner` | Non-owner upgrade → reverts |
| `test_upgrade_success` | Owner upgrades implementation |
| **Fuzz tests** | |
| `testFuzz_claimReward_randomSourceIndex` | Random indices with valid proofs |
| `testFuzz_wrongProof_alwaysReverts` | Random proof bytes always fail |

**Coverage target: 100% line + branch coverage** (verified via `forge coverage`).

---

## Part 2: Rust Proof Service

### Step 2.1: Workspace Setup

Cargo workspace with three crates: `proof-gen`, `service`, `test-vectors`.

**Key dependencies:**
| Crate | Purpose |
|---|---|
| `ssz_rs` (git) | SSZ types + Merkle proof generation via `Prove` trait |
| `alloy` 1.5 | Gnosis Chain tx submission |
| `axum` | REST API framework |
| `reqwest` | HTTP client for Beacon API |
| `tokio` | Async runtime |
| `serde` / `serde_json` | Test vector serialization |
| `metrics` + `metrics-exporter-prometheus` | Prometheus metrics |
| `tracing` | Structured logging |

### Step 2.2: `proof-gen` Crate — Core Logic

#### `types.rs` — Beacon State Types

Define SSZ types using `ssz_rs_derive` matching the Electra BeaconState layout. Only the fields we need must be correct; others can be opaque `[u8; 32]` placeholders as long as SSZ offsets are preserved.

Key types:
```rust
#[derive(ssz_rs::Serializable, ssz_rs::Merkleized, ssz_rs::GeneralizedIndexable)]
struct PendingConsolidation {
    source_index: u64,
    target_index: u64,
}

#[derive(ssz_rs::Serializable, ssz_rs::Merkleized, ssz_rs::GeneralizedIndexable)]
struct Validator {
    pubkey: Vector<u8, 48>,
    withdrawal_credentials: [u8; 32],
    effective_balance: u64,
    slashed: bool,
    activation_eligibility_epoch: u64,
    activation_epoch: u64,
    exit_epoch: u64,
    withdrawable_epoch: u64,
}

// Full ElectraBeaconState with all 37 fields...
```

Support **both presets** via Rust generics or feature flags:
- `minimal`: `PENDING_CONSOLIDATIONS_LIMIT=64`, `SLOTS_PER_EPOCH=8`
- `gnosis` (= mainnet): `PENDING_CONSOLIDATIONS_LIMIT=262144`, `SLOTS_PER_EPOCH=16`

#### `beacon_client.rs` — Beacon API Client

```rust
impl BeaconClient {
    async fn get_state_ssz(&self, slot: u64) -> Result<Vec<u8>>
    // GET /eth/v2/debug/beacon/states/{slot}  Accept: application/octet-stream

    async fn get_header(&self, slot: u64) -> Result<BeaconBlockHeader>
    // GET /eth/v1/beacon/headers/{slot}

    async fn get_finality_checkpoints(&self) -> Result<FinalityCheckpoints>
    // GET /eth/v1/beacon/states/head/finality_checkpoints
}
```

#### `proof.rs` — Proof Computation

```rust
struct ConsolidationProofBundle {
    beacon_timestamp: u64,
    consolidation_index: u64,
    source_index: u64,
    activation_epoch: u64,
    source_credentials: [u8; 32],
    proof_consolidation: Vec<[u8; 32]>,    // 29 elements (gnosis)
    proof_credentials: Vec<[u8; 32]>,      // 53 elements
    proof_activation_epoch: Vec<[u8; 32]>, // 53 elements
}

impl ProofGenerator {
    fn generate_proof(
        state: &ElectraBeaconState,
        consolidation_index: usize,
    ) -> Result<ConsolidationProofBundle>
}
```

Uses `ssz_rs::Prove::prove()` with paths:
- `["pending_consolidations", Index(i), "source_index"]`
- `["validators", Index(source_idx), "withdrawal_credentials"]`
- `["validators", Index(source_idx), "activation_epoch"]`

#### `gindex.rs` — Generalized Index Math

Compute and verify gindices match Solidity contract expectations. Used for cross-validation in tests.

### Step 2.3: `service` Crate — Auto-Submitter + API

#### `scanner.rs` — Beacon Chain Scanner

Continuously polls the beacon chain (via Beacon API) for new finalized states:
1. Track the latest finalized epoch
2. Fetch state at each new finalized slot
3. Extract `pending_consolidations` list
4. For each new consolidation, check if already rewarded on-chain (call `rewarded(sourceIndex)`)
5. If not rewarded, queue for proof generation + submission

#### `submitter.rs` — Transaction Submitter

```rust
impl Submitter {
    // Uses alloy Provider + Signer
    async fn submit_claim(&self, proof: ConsolidationProofBundle) -> Result<TxHash>
    // Calls claimReward() on the contract
    // Handles gas estimation, nonce management, retries
}
```

**Configuration:**
- Gnosis RPC URL
- Contract address
- Signer private key (or KMS)
- Gas price limits

#### `api.rs` — REST API (Axum)

| Endpoint | Method | Description |
|---|---|---|
| `/health` | GET | Health check (degraded if >64 slots behind) |
| `/status` | GET | Sync status: current slot/epoch, head slot, slots behind |
| `/consolidations` | GET | List consolidations with status: `detected`, `proof_built`, `submitted`, `confirmed`, `failed` |
| `/consolidations/:source_index` | GET | Single consolidation detail |
| `/metrics` | GET | Prometheus metrics endpoint |

#### `state.rs` — Shared Application State

```rust
struct AppState {
    current_slot: AtomicU64,
    current_epoch: AtomicU64,
    consolidations: DashMap<u64, ConsolidationRecord>,
    // ConsolidationRecord { source_index, target_index, epoch_seen, status, tx_hash, error }
}
```

**Prometheus metrics:**
- `sync_current_slot`, `sync_slots_behind` (gauges)
- `consolidations_detected_total`, `proofs_submitted_total`, `proofs_confirmed_total`, `proofs_failed_total` (counters)
- `proof_generation_duration_seconds`, `tx_submission_duration_seconds` (histograms)
- `rewards_distributed_total_xdai` (gauge)

### Step 2.4: `test-vectors` Crate — Shared Test Data Generator

A binary that generates JSON test vectors for use in both Rust tests and Foundry tests.

**Process:**
1. Construct minimal BeaconState objects using the **minimal preset** (small enough to build in-memory)
2. Populate with known validators and pending_consolidations
3. Compute `hash_tree_root` of a BeaconBlockHeader wrapping the state
4. Generate all three proofs for each consolidation
5. Export as JSON files to `contracts/test-vectors/`

**Test vector JSON format:**
```json
{
  "preset": "minimal",
  "block_root": "0x...",
  "beacon_timestamp": 12345,
  "claims": [
    {
      "consolidation_index": 0,
      "source_index": 42,
      "activation_epoch": 100,
      "source_credentials": "0x01000000000000000000000000001234567890abcdef1234567890abcdef1234",
      "proof_consolidation": ["0x...", ...],
      "proof_credentials": ["0x...", ...],
      "proof_activation_epoch": ["0x...", ...],
      "expected_recipient": "0x1234567890abcdef1234567890abcdef1234"
    }
  ],
  "invalid_claims": [
    {
      "description": "wrong source_index for proof",
      "consolidation_index": 0,
      "source_index": 99,
      "...fields...": "...",
      "expected_error": "InvalidProof"
    }
  ]
}
```

**Important — minimal vs gnosis preset handling:**

The minimal preset has `PENDING_CONSOLIDATIONS_LIMIT=64` (depth 6) vs gnosis `262144` (depth 18). This means proof lengths differ. Two approaches:

- **Option A**: Make the Solidity contract preset-aware (configurable depths). More complex but allows testing with minimal preset vectors directly.
- **Option B**: Generate test vectors with the gnosis/mainnet preset from small hand-crafted states. The states are larger in memory but still constructible for tests. Contract stays simple with hardcoded gnosis depths.

**Recommendation: Option A** — The `SSZMerkleVerifier.verifyProof()` already accepts variable-length proofs and validates length against `log2(gindex)`. The gindex computation functions are what change between presets. We can make the contract accept proof depths dynamically (they're validated against the gindex), and test with minimal preset vectors. For production deployment, the gindex functions are hardcoded for gnosis preset.

Actually simpler: generate gnosis-preset test vectors even though minimal preset has different limits. The Rust test-vector generator can use gnosis preset constants to build the state type with the correct list limits, then populate only a few entries. The BeaconState will be large in SSZ tree form but the proof generator handles it. The Solidity tests then work without any preset parameterization.

### Step 2.5: Rust Tests

#### Unit tests (`proof-gen`)
- Proof generation for known small trees
- Gindex computation matches expected values
- Round-trip: generate proof → verify against root
- Cross-check gindices with Solidity contract constants

#### Integration tests
- Load test vectors → verify proofs match expected
- Full pipeline: construct state → generate proofs → verify
- Beacon client mock tests (mock HTTP responses)

---

## Part 3: Monitoring & Visualization

### Dune Analytics Dashboard

Submit contract for decoding on Dune after deployment. SQL queries:

**`total_rewards.sql`** — Total rewards distributed over time
```sql
SELECT date_trunc('day', evt_block_time) as day,
       COUNT(*) as claims,
       SUM(rewardAmount) / 1e18 as total_xdai
FROM consolidation_incentives_gnosis.ConsolidationIncentives_evt_RewardClaimed
GROUP BY 1 ORDER BY 1
```

**`consolidations_over_time.sql`** — Cumulative consolidation chart

**`top_validators.sql`** — Largest consolidators by count

### Proof Service Dashboard

The Rust service exposes `/status` and `/consolidations` for operational visibility. For richer visualization:
- Prometheus scrapes `/metrics` → Grafana dashboards for operational monitoring
- The `/consolidations` endpoint provides a JSON list suitable for a simple HTML status page

---

## Implementation Order

| # | Component | Description |
|---|---|---|
| 1 | Foundry scaffolding | Project init, deps, config |
| 2 | `SSZMerkleVerifier.sol` | Proof verification library |
| 3 | `ConsolidationIncentives.sol` | Main contract |
| 4 | `MockBeaconRootsOracle.sol` | Test mock for EIP-4788 |
| 5 | Rust workspace scaffolding | Cargo workspace, deps |
| 6 | `proof-gen` types + gindex | SSZ types, gindex computation |
| 7 | `proof-gen` proof generation | Proof computation using ssz_rs |
| 8 | `test-vectors` binary | Generate JSON test vectors |
| 9 | Solidity tests (load vectors) | All tests listed above, 100% coverage |
| 10 | `SSZMerkleVerifier.t.sol` | Proof library unit tests |
| 11 | Rust `beacon_client` | Beacon API HTTP client |
| 12 | Rust `scanner` | Consolidation detection loop |
| 13 | Rust `submitter` | On-chain tx submission |
| 14 | Rust `api` | REST API + Prometheus metrics |
| 15 | Rust integration tests | End-to-end pipeline tests |
| 16 | `Deploy.s.sol` | Deployment script |
| 17 | Dune queries | Analytics SQL |
